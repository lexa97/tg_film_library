# Правила проекта: Telegram-бот «Кинобиблиотека группы»

## Документация проекта

Полная спецификация находится в файле:
- **task.md** — техническое задание: цели, сценарии, модель данных, БД, TMDB, этапы разработки.

Дополнительно: **rules.md** — архитектурные принципы (если есть).

**ВАЖНО:** Перед началом работы прочитай task.md для понимания контекста.

---

## 1. Архитектура проекта

### Структура кода

```
app/
  handlers/       # Обработчики сообщений и callback'ов Telegram (aiogram)
  keyboards/      # Inline- и reply-клавиатуры
  db/             # SQLAlchemy, модели БД, репозитории / сервисы доступа к БД
  middlewares/    # Middlewares для запросов (например, сессия БД)
  services/       # Бизнес-логика и работа с TMDB
  states/         # FSM-состояния (создание группы и др.)
  utils/          # Вспомогательные функции
```

### Разделение ответственности (SRP)

- **Handlers** — приём обновлений от Telegram, валидация входных данных, вызов сервисов, формирование ответа (сообщения, клавиатуры).
- **Services** — бизнес-логика: пользователи/группы, фильмы, список «к просмотру», отметка «просмотрен», интеграция с TMDB.
- **Repositories / db** — доступ к БД (CRUD по сущностям).
- **Keyboards** — только сборка клавиатур по данным от сервисов.

**В хендлерах не должно быть бизнес-логики** (проверка прав, расчёты, решение «добавить или нет» — только вызов сервисов).

---

## 2. Код только на классах

**Вся бизнес-логика реализуется через классы.**

### ✅ Правильно

```python
class UserGroupService:
    async def add_member_by_contact(self, group_id: int, contact: Contact) -> Member:
        # логика добавления по contact.user_id
        pass

class FilmService:
    async def search_films(self, query: str, language: str) -> list[FilmSearchResult]:
        # вызов TMDB, маппинг в наши модели
        pass

class GroupFilmService:
    async def mark_watched(self, group_film_id: int, user_id: int) -> None:
        # отметка «просмотрен» для группы
        pass
```

### ❌ Нельзя

```python
async def add_member_by_contact(group_id: int, contact):  # функция на верхнем уровне
    pass
```

### Допустимые функции

- Приватные утилиты внутри классов.
- Хелперы в `utils/` только для технических задач (форматирование, парсинг), не бизнес-логика.
- Регистрация хендлеров и роутеров в `main.py` / пакетах handlers.

---

## 3. Наследование и базовые классы

Используй базовые/абстрактные классы там, где есть общая логика:

```python
class BaseFilmSearchProvider(ABC):
    @abstractmethod
    async def search(self, query: str, language: str) -> list[FilmSearchResult]:
        pass

class TMDBFilmSearch(BaseFilmSearchProvider):
    async def search(self, query: str, language: str) -> list[FilmSearchResult]:
        # вызов TMDB API
        pass
```

**Запрещено:** копипаста логики между сервисами; длинные цепочки `if/else` по типу сущности — предпочтительнее полиморфизм (разные классы под TMDB/другие источники).

---

## 4. Слой хендлеров (Telegram)

### Хендлер должен делать только:

1. Извлечение данных из `message` / `callback` (текст, `contact`, `callback_data`).
2. Валидация/нормализация входных данных (при необходимости — Pydantic).
3. Проверка контекста (пользователь в группе, права админа — через сервисы или middleware).
4. Вызов метода сервиса.
5. Формирование ответа: сообщение + клавиатура (через `keyboards`).

### ❌ В хендлерах запрещено:

- Прямые запросы к БД (только через сервисы/репозитории).
- Логика «добавить в группу или нет», «можно ли отметить просмотренным» — только в сервисах.
- Парсинг TMDB-ответов — только в `services` (например, `tmdb.py` / `film.py`).

### ✅ Пример

```python
# В handlers/group.py или отдельном файле
async def add_member_by_contact_handler(message: Message, service: UserGroupService):
    if not message.contact:
        await message.answer("Отправьте контакт пользователя (Поделиться контактом).")
        return
    contact = message.contact
    # Проверка прав и выбор группы — в сервисе или отдельном методе
    result = await service.add_member_by_contact_for_current_admin(contact)
    await message.answer(f"Пользователь добавлен в группу «{result.group_name}».")
    # Уведомление участникам — внутри сервиса или отдельный вызов
```

---

## 5. Pydantic-модели

**Все структурированные входные и выходные данные — через Pydantic-модели.**

- Запросы/ответы между слоями (сервис ↔ хендлер).
- Данные из TMDB (внутренние DTO).
- Конфигурация (pydantic-settings).

### ❌ Нельзя

```python
async def save_film(data: dict):  # dict между слоями
    pass
```

### ✅ Правильно

```python
class FilmCreate(BaseModel):
    external_id: str
    source: str
    title: str
    title_original: str | None
    year: int | None
    description: str | None
    poster_url: str | None

async def add_film_to_group(self, group_id: int, film: FilmCreate, added_by_user_id: int) -> GroupFilm:
    ...
```

---

## 6. Работа с БД

Доступ к БД **только через репозитории или сервисы доступа к данным** (один слой в `db/`).

```python
class UserRepository:
    async def get_by_telegram_id(self, telegram_user_id: int) -> User | None:
        ...

class GroupRepository:
    async def get_by_admin_id(self, admin_user_id: int) -> Group | None:
        ...
```

- Один репозиторий — одна сущность (users, groups, films, group_films, watched).
- Репозитории не содержат бизнес-логики (только CRUD).
- Сервисы вызывают репозитории, не наоборот.

Миграции — Alembic, схема БД по п. 7 task.md (users, groups, group_members, films, group_films, watched).

---

## 7. Сервисы и TMDB

- Вся работа с TMDB (поиск, детали, переводы/альтернативные названия) — в `services/` (например, `tmdb.py`, `film.py`).
- Абстракция «поисковик» (интерфейс) + реализация под TMDB; при расширении — вторая реализация (например, OMDb) без смены сценариев бота.
- Учёт лимитов запросов TMDB и при необходимости кэширование — в сервисе.

---

## 8. Пользователи и группы

- **Группа** — логическая сущность в боте (название + участники), не чат Telegram. Взаимодействие с ботом — в **личном чате**.
- Добавление в группу: пользователь сначала `/start`, затем админ отправляет контакт. Использовать `message.contact.user_id` (aiogram: `contact.user_id`), если передан контакт из Telegram.
- Один пользователь — одна группа в MVP (выбор группы в сценариях не показываем).
- Роли: admin (создатель группы), member. Проверка прав — в сервисах, хендлер только вызывает сервис.

---

## 9. Фильмы и список «к просмотру»

- Поиск: текстовое сообщение от пользователя в группе → поиск в TMDB с учётом языка/переводов/альтернативных названий.
- Результаты: до N вариантов (например, 5); карточка (название, год, описание, постер) + inline-кнопка «Подтвердить».
- Подтверждение: сохранение в `films` и `group_films`, уведомление участникам группы.
- Список: `/list` или кнопка «Мой список» — список фильмов группы (inline-кнопки по названиям, пагинация при необходимости). По нажатию на фильм — описание + кнопка «Просмотрено».
- Отметка «просмотрен» — общая на группу (одна галочка на `group_film`). По нажатию «Просмотрено» — уведомление участникам группы.

---

## 10. Команды и FSM

- `/start` — приветствие; если пользователь не в группах — текст про «нажмите /start и попросите админа добавить по контакту»; иначе — меню (создать группу, мой список и т.д.).
- `/list` — вывод списка группы (inline-кнопки, по нажатию — описание + «Просмотрено»).
- Создание группы: FSM в `states/` — запрос названия → создание группы → сообщение об успехе.
- Добавление участника: админ отправляет контакт боту (без выбора группы в MVP).

---

## 11. Технологический стек

- Python 3.11+
- aiogram 3.x
- PostgreSQL 14+
- Alembic (миграции)
- SQLAlchemy (async)
- pydantic-settings, .env
- TMDB API (поиск фильмов/сериалов, мультиязычность)

---

## 12. Принципы кода

1. **Явно лучше, чем магия** — без лишнего метапрограммирования.
2. **Простота важнее универсальности** — MVP: одна группа на пользователя, один источник фильмов (TMDB).
3. **Читаемость** — если код «умный», лучше упростить.
4. **Расширяемость через классы** — новый источник фильмов = новый класс провайдера, не раздувание if/else.

---

## 13. При добавлении нового функционала

1. Прочитай **task.md** (и при необходимости rules.md).
2. Определи модели данных (Pydantic и/или SQLAlchemy при необходимости).
3. Добавь/используй репозитории в `db/`.
4. Реализуй логику в **сервисах** в `services/`.
5. Добавь хендлеры в `handlers/`, клавиатуры в `keyboards/`, при необходимости FSM в `states/`.
6. Не смешивай слои: хендлер не лезет в БД, сервис не знает про типы Telegram (Message, CallbackQuery — только в handlers).

---

## 14. Безопасность и лимиты

- Пароли не используются (авторизация через Telegram).
- TMDB: соблюдать лимиты запросов, при необходимости кэшировать.
- Контакт: в MVP полагаемся на `contact.user_id` при «Поделиться контактом»; сценарий без `user_id` (только номер) не поддерживаем.

---

## Итог

**Ключевое правило:** разделение ответственности. Хендлеры только принимают обновления и вызывают сервисы. Сервисы содержат бизнес-логику и работают с репозиториями и TMDB. Репозитории только работают с БД.

**Вся бизнес-логика — в классах (сервисах). Функции — только утилиты и регистрация роутеров.**

Спецификация проекта: **task.md**.
